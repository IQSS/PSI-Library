% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utilities-tree.R
\name{initialize}
\alias{initialize}
\title{Binary Tree Creation}
\arguments{
\item{range}{Range: An array of two numeric values that indicate the range of data that will be bucketed
in the tree structure. The first value should be the minimum (inclusive) and the second should be the
maximum (exclusive).}

\item{nLeaves}{Number of leaves: A whole, positive number, indicating the number of leaves the tree should have.}

\item{data}{Array of numeric data values to bin.}

\item{range}{Array of numeric data of length 2; the range that the desired histogram will span.
Array of form c(min, max), where the first value, min, is the minimum of the range, and the second value, max is the maximum of the range.}

\item{nLeaves}{Numeric, the number of leaves in the tree, i.e. the number of histogram bins at their most granular.

By a 'tree statistic' here we simply mean a sort of glorified histogram: imagine you have a perfect tree, and each of the leaves represent a 
range [x,y]. You could then bucket data points by incrementing the weight of a leaf by 1 for every data point that lies within the range
represented by that bucket. If we just binned things based on the leaves of the tree, this is equivalent to a normal histogram, where the
weights of the leaves is the count of each histogram bucket.

However, we could also more generally assign ranges and weights to all nodes of the tree, by saying that nodes span the ranges of their combined
children and have weights equal to their combined children's weights. Formally, If [x1,y1] is the range of a node's left child and  [x2,y2] is 
the range of a node's right child, then say that node has range [x1,y2]. Similarly, if a node's left child has weight A and its right
child has weight B, then that node will have weight A+B. 

This 'tree' statistic gives us a way to calculate the CDF of a function with fewer queries. This is not so useful in the context of a public
statistic, where we know the bin counts with certainty. But in the differentially private setting, fewer queries corresponds to a reduction in
error in the calculation of the CDF.

 The below example will create a tree with 2 leaves that range [0,4). The root node has range [0,4),
its left child will have range [0,2), and its right child will have range [2,4). 
The data, c(1,1,4) is then binned into each of these nodes. Since the head includes all points, 
it will have weight 5. Its left child will have weight 4, since there are 4 points in the data that
lie in the range [0,2), and its right child will have weight 1, since there is 1 point in the data
that lies in the range [2,4).}
}
\description{
Framework to creates a binary tree. Each node is a bucket over some data range, and its weight
will be incremented by 1 for every data point that is within this range. This object
only initializes the tree structure itself, given the total range \code{range} of the data that
will be inserted and \code{nLeaves}, the number of leaf nodes to bucket the data in. The 
actual bucketing of data occurs within the publicTreeStatistic object that inherits from this 
basic Tree structure.
}
\details{
E.g. given range \code{range = c(0,4)} and \code{nLeaves=2}, Tree$new(range,nLeaves) 
will create a tree of depth 2 that will have 2 leaves, with one bucketing data between \eqn{[0,2)}
and one bucketing data between \eqn{[2,4)}.

If a parent node has a left child with range \eqn{[min1, max1)} and a right child with range
\eqn{[min2, max2)}, then the parent node will have range \eqn{[min1, max2)}.
As currently instantiated, nLeaves is required to be a power of 2 (i.e. the constructed tree is a
perfect binary tree).
}
\examples{
data <- c(1,1,1,1,3)
t <- publicTreeStatistic$new(data,c(0,4),2)
}
